数据结构概述
    定义 : 我们如何将现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器(内存)中,以及在此基础上为实现某个功能(比如查找某个元素，删除某个元素，对所有元素进行排序)而执行的相应操作，这个相应的操作也叫做算法

        个体的存储和个体与个体之间的关系
        数据结构 = 个体 + 个体的关系
        算法 = 对存储数据的操作

        数据结构解决存储的问题，算法解决操作的问题

    算法 : 解题的方法和步骤
       衡量算法的标准
           1.时间复杂度 : 大概程序要执行的次数，而非执行的时间

           2.空间复杂度 : 算法执行过程中大概所占用的最大内存

           3.难易程度 : 可读性

           4.健壮性

     数据结构的地位 : 是软件中最核心的课程

     软件 = 数据的存储 + 数据的操作 + 可以被计算机识别的语言

预备的知识 : 指针
           结构体
           动态内存的分配和释放


模块一 : 线性结构 -- 把所有的节点用一根直线穿起来

    连续存储[数组]

    离散存储[链表]
        定义:n各节点离散分配
            彼此通过指针相连
            每个节点只有一个前驱节点，每个节点只有一个后续节点
            首节点没有前驱节点，尾节点没有后续节点

        专业术语:
            首节点：第一个有效的节点
            尾节点：最后一个有效的节点
            头结点：第一个有效节点之前的那个节点
                   头结点并不存储有效数据
                   加头结点的目的主要是为了方便对链表的操作
            头指针：指向头结点的指针变量
            尾指针：指向尾节点的指针变量

         确定一个链表需要几个参数：只需要头指针，因为我们可以通过头指针推算出链表的其他所有信息

         分类：
             单链表
             双链表：每一个节点有两个指针域

             循环链表：能通过任何一个节点找到其他所有的节点
             非循环链表

          算法：遍历、查找、清空、销毁、求长度、排序、删除节点、插入节点

               狭义的算法是与数据的存数方式密切相关
               广义的算法是与数据的存储方式无关
               泛型 : 利用某种技术达到的效果就是：不同的存数方式，执行的操作是一样的

    线性结构的两种常见应用之一 栈
         定义：一种可以实现“先进后出”的储存结构
              栈类似于箱子

         分类：静态栈
              动态栈

         算法：出栈
              压栈

         应用：函数调用
              中断
              表达式求值
              内存分配
              缓冲处理
              迷宫

    线性结构的两种常见应用之二 队列
         定义：一中可以实现“先进先出”的存储结构

         分类：链式队列 -- 用链表实现

              静态队列 -- 用数组实现
                 静态队列通常都必须实现循环队列

              循环队列的讲解：
                  1.静态队列为什么必须是循环队列

                  2.循环队列需要几个参数来确定
                     需要两个参数来确定
                        front rear
                     两个参数不同场合有不同的含义
                     1).队列初始化
                        font和rear的值都是零
                     2).队列非空
                        front代表的是队列的第一个元素
                        rear代表的时队列的最后一个有效元素的后一个元素
                     3).队列空
                        front和rear的值相等，但不一定为零

                  3.循环队列入队的伪算法
                    两步完成：1.将值存入r所代表的位置
                            2.错误写法：r = r + 1；
                              正确写法：r = (r + 1) % (数组的长度)

                  4.循环队列出队的伪算法
                    f = (f + 1) % (数组的长度)

                  5.如何判断循环队列是否为空
                    如果front 与 rear的值相等，那么该队列就一定为空

                  6.如何判断循环队列是否已满
                    预备知识：front的值可能比rear大、小或者相等
                    两种方式：1.多增加一个表标识参数
                            2.少用一个元素【通常使用第二种方式】
                                  如果r和f的值紧挨着，则队列已满
                                  if( (r+1)%数组的长度 == f){
                                      已满
                                  } else {
                                      不满
                                  }
        队列算法：入队、出队

递归 -- 定义：一个函数自己直接或间接调用自己

        递归满这三个条件：
            1.递归必须有一个明确的终止条件
            2.该函数所处理的数据规模必须在递减
            3.这个转化必须是可解的

       递归和循环
           递归：易于理解、速度慢、存储空间大
           循环：不易理解、速度快、存储空间小

逻辑结构 -- 线性->数组、链表
           栈和队列是一种特殊的线性结构、都可以用数组和链表实现

        -- 非线性->树、图


模块二 : 非线性结构

    树 -- 定义 -- 1.有且只有一个称为跟的节点
                 2.有若干个互不相交的子树，这些子树本身也是一棵树
       -- 通俗定义:1.树由节点和边组成
                  2.每个节点只有一个父节点但可以有多个子节点
                  3.有一个节点例外，该节点没有父节点，此节点称为根节点

       -- 深度：从根节点到最底层节点的层数称之为深度
               根节点是第一层
       -- 叶子节点：没有子节点的节点
       -- 非终端节点：实际上就是非叶子节点
       -- 度 -- 子节点的个数称为度

       数分类 -- 一般树：任意一个节点的子节点的个数都不受限制
             -- 二叉树：任意一个节点的子节点个数最多两个，且子节点的位置不可更改

                     分类：一般二叉树
                          满二叉树：在不增加层数的情况下，无法再增加一个节点的二叉树
                          完全二叉树：如果只是删除了满二叉树最低层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树

             -- 森林 ：n个互不相交的树的集合

       数的存储 -- 二叉树的存储
                       连续存储[完全二叉树]
                           优点：查找某个节点的父节点和子节点(也包括判断有没有父节点和子节点)
                           缺点：耗用内存空间大
                       链式存储

               -- 一般树的存储
                        双亲表示法  求父节点方便
                        孩子表示法  求子节点方便
                        双亲孩子表示法  都方便
                        二叉树表示法：把一个普通树转化成二叉树来存储
                              条件：任意一个节点的
                                   左指针域指向它的第一个孩子
                                   右指针域指向它的兄弟
                                   只要满足，就可以把一个普通树转化成二叉树
                        一个普通树转化成的二叉树一定没有右子树

               -- 森林的存储
                       先把森林转化成二叉树，再存储二叉树

        二叉树操作
             遍历 -- 先序遍历【先访问根节点】
                        先访问根节点
                        再先序访问左子树
                        在先序访问右子树

                 -- 中序遍历【中间访问根节点】
                        中序遍历左子树
                        再访问根节点
                        再中序遍历右子树

                 -- 后序遍历【最后访问根节点】
                        中序遍历左子树
                        中序遍历右子树
                        再访问根节点

             已知两种遍历序列求原始二叉树
                     只有通过先序和中序，或者通过中序和后序
                     我们才能唯一的确定一个二叉树【必须有中序】

        应用
            树是数据库中数据组织一种重要形式
            操作系统子父进程的关系本身就是一棵树
            面向对象语言中类的继承关系
            赫夫曼树

    图

模块三 : 查找和排序

    折半查找

    排序 :
         冒泡
         插入
         选择
         快速排序
         归并排序

    排序和查找的关系
         排序是查找的前提
         排序是重点
